use crate::dump::core::Dump;
use std::{
    collections::HashSet,
    fs::File,
    io::{Error, Write},
};

// This is a Dump comparer that generates a script comparing two PostgreSQL dumps.
// The result script, if it will be applied on "from" dump database, will make it equal to "to" dump database.
pub struct Comparer {
    // The dump to compare from
    from: Dump,
    // The dump to compare to
    to: Dump,
    // Whether to use DROP statements in the output
    use_drop: bool,

    // The script that will be generated
    script: String,
    enum_pre_script: String,
    enum_post_script: String,
    dropped_views: HashSet<String>,
}

impl Comparer {
    // Creates a new Comparer with the given dumps
    pub fn new(from: Dump, to: Dump, use_drop: bool) -> Self {
        let mut comparer = Self {
            from,
            to,
            use_drop,
            script: String::new(),
            enum_pre_script: String::new(),
            enum_post_script: String::new(),
            dropped_views: HashSet::new(),
        };

        comparer.script.push_str("/*\n");
        comparer
            .script
            .push_str("Script generated by PostgreSQL Comparer\n\n");
        comparer.script.push_str(" From dump:\n");
        comparer.script.push_str(&comparer.from.get_info());
        comparer.script.push_str("\n\n To dump:\n");
        comparer.script.push_str(&comparer.to.get_info());
        comparer.script.push_str(&format!(
            "\n\n Comparison results (use_drop: {}):\n",
            comparer.use_drop
        ));
        comparer.script.push_str("*/\n\n");

        comparer
    }

    // Compare dumps and generate the script
    pub async fn compare(&mut self) -> Result<(), Error> {
        self.compare_schemas().await?;
        self.compare_extensions().await?;
        self.compare_enums().await?;
        if !self.enum_pre_script.is_empty() {
            self.script.push_str(&self.enum_pre_script);
            self.enum_pre_script.clear();
        }
        self.compare_types().await?;
        if !self.enum_post_script.is_empty() {
            self.script.push_str(&self.enum_post_script);
            self.enum_post_script.clear();
        }
        self.compare_sequences().await?;
        self.drop_views().await?;
        self.compare_tables().await?;
        self.create_views().await?;
        self.compare_routines().await?;

        Ok(())
    }

    // Returns the script generated by the comparer
    fn get_script(&self) -> String {
        self.script.clone()
    }

    fn normalized_view_reference(reference: &str) -> String {
        reference
            .trim()
            .chars()
            .filter(|c| !matches!(c, '"' | '\'' | '`'))
            .collect::<String>()
            .to_lowercase()
    }

    fn normalized_view_key(schema: &str, name: &str) -> String {
        Self::normalized_view_reference(format!("{}.{}", schema, name).as_str())
    }

    fn dependent_view_keys(&self) -> HashSet<String> {
        let mut dependent_views = HashSet::new();

        for table in &self.from.tables {
            for column in &table.columns {
                if let Some(related_views) = &column.related_views {
                    for view_ref in related_views {
                        let normalized = Self::normalized_view_reference(view_ref);
                        if !normalized.is_empty() {
                            dependent_views.insert(normalized);
                        }
                    }
                }
            }
        }

        dependent_views
    }

    // Saves the generated script to a file
    pub async fn save_script(&self, output: &str) -> Result<(), Error> {
        let mut file = File::create(output)?;
        file.write_all(self.get_script().as_bytes())?;
        Ok(())
    }

    async fn compare_schemas(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Schemas: Start section --------------- */\n\n");

        // We will find all new schemas from "to" dump that are not in "from" dump
        // and add them to the script.
        for schema in &self.to.schemas {
            if let Some(_from_schema) = self.from.schemas.iter().find(|s| s.name == schema.name) {
                continue; // Schema is present in both dumps, we already processed it
            } else {
                self.script
                    .push_str(format!("\n/* Schema: {}*/\n", schema.name).as_str());
                self.script.push_str(schema.get_script().as_str());
            }
        }

        // We will find all schemas that exists just in "from" dump.
        // Drop will be added just if use_drop is true
        // TODO: We need to drop schema only if it's empty (no objects inside) Maybe the best way is to just skip dropping.
        /*
        for schema in &self.from.schemas {
            if let Some(_to_schema) = self
                .to
                .schemas
                .iter()
                .find(|s| s.name == schema.name)
            {
                continue; // Schema is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Schema: {}*/
\n", schema.name).as_str());
                self.script.push_str(
        " /* Schema is not present in 'to' dump and should be dropped. */
\n",
                );
                self.script.push_str(schema.get_drop_script().as_str());
            }
        }*/

        self.script
            .push_str("\n/* ---> Schemas: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing extentions
    async fn compare_extensions(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Extensions: Start section --------------- */\n\n");

        // We will find all new extensions from "to" dump that are not in "from" dump
        // and add them to the script.
        // Also we will find only in "from" dump extensions that are not in "to" dump and drop them.
        for ext in &self.to.extensions {
            if let Some(_from_ext) = self
                .from
                .extensions
                .iter()
                .find(|r| r.name == ext.name && r.schema == ext.schema)
            {
                continue; // Extension is present in both dumps, we already processed it
            } else {
                self.script
                    .push_str(format!("/* Extension: {}.{}*/\n", ext.schema, ext.name).as_str());
                self.script.push_str(ext.get_script().as_str());
            }
        }

        for ext in &self.from.extensions {
            if let Some(_to_ext) = self
                .to
                .extensions
                .iter()
                .find(|r| r.name == ext.name && r.schema == ext.schema)
            {
                continue; // Routine is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Extension: {}.{}*/\n", ext.schema, ext.name).as_str());
                self.script.push_str(
                    "/* Extension is not present in 'to' dump and should be dropped. */\n",
                );
                self.script.push_str(ext.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> Extensions: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing types
    async fn compare_types(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> User-defined types: Start --------------- */\n\n");

        for to_type in &self.to.types {
            if (to_type.typtype as u8 as char) == 'e' {
                continue;
            }
            if let Some(from_type) = self
                .from
                .types
                .iter()
                .find(|t| t.schema == to_type.schema && t.typname == to_type.typname)
            {
                if from_type.hash() != to_type.hash() {
                    self.script.push_str(
                        format!("/* Type: {}.{} */\n", to_type.schema, to_type.typname).as_str(),
                    );
                    let alter_script = from_type.get_alter_script(to_type);
                    if alter_script.trim().is_empty() {
                        self.script.push_str(
                            "-- No supported alterations for this type; manual review required.\n",
                        );
                    } else {
                        self.script.push_str(alter_script.as_str());
                    }
                }
            } else {
                self.script.push_str(
                    format!("/* Type: {}.{} */\n", to_type.schema, to_type.typname).as_str(),
                );
                self.script.push_str(to_type.get_script().as_str());
            }
        }

        if self.use_drop {
            for from_type in &self.from.types {
                if (from_type.typtype as u8 as char) == 'e' {
                    continue;
                }
                if self
                    .to
                    .types
                    .iter()
                    .any(|t| t.schema == from_type.schema && t.typname == from_type.typname)
                {
                    continue;
                }

                self.script.push_str(
                    format!("/* Type: {}.{} */\n", from_type.schema, from_type.typname).as_str(),
                );
                self.script
                    .push_str("/* Type is not present in 'to' dump and should be dropped. */\n");
                self.script.push_str(from_type.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> User-defined types: End --------------- */\n\n");
        Ok(())
    }

    // Comparing enums
    async fn compare_enums(&mut self) -> Result<(), Error> {
        let mut create_alter_section = String::new();
        create_alter_section.push_str("\n/* ---> Enums: Start --------------- */\n\n");

        let mut drop_section = String::new();

        let to_enums = self
            .to
            .types
            .iter()
            .filter(|t| (t.typtype as u8 as char) == 'e');

        for to_enum in to_enums {
            if let Some(from_enum) = self
                .from
                .types
                .iter()
                .find(|t| t.schema == to_enum.schema && t.typname == to_enum.typname)
            {
                if from_enum.hash() != to_enum.hash() {
                    create_alter_section.push_str(
                        format!("/* Enum: {}.{} */\n", to_enum.schema, to_enum.typname).as_str(),
                    );
                    let alter_script = from_enum.get_alter_script(to_enum);
                    if alter_script.trim().is_empty() {
                        create_alter_section.push_str(
                            "-- No supported alterations for this enum; manual review required.\n",
                        );
                    } else {
                        create_alter_section.push_str(alter_script.as_str());
                    }
                }
            } else {
                create_alter_section.push_str(
                    format!("/* Enum: {}.{} */\n", to_enum.schema, to_enum.typname).as_str(),
                );
                create_alter_section.push_str(to_enum.get_script().as_str());
            }
        }

        if self.use_drop {
            for from_enum in self
                .from
                .types
                .iter()
                .filter(|t| (t.typtype as u8 as char) == 'e')
            {
                if self
                    .to
                    .types
                    .iter()
                    .any(|t| t.schema == from_enum.schema && t.typname == from_enum.typname)
                {
                    continue;
                }

                if drop_section.is_empty() {
                    drop_section.push_str(
                        "\n/* ---> Enums: Drop section (execute after dependent types) --------------- */\n\n",
                    );
                }
                drop_section.push_str(
                    format!("/* Enum: {}.{} */\n", from_enum.schema, from_enum.typname).as_str(),
                );
                drop_section
                    .push_str("/* Enum is not present in 'to' dump and should be dropped. */\n");
                drop_section.push_str(from_enum.get_drop_script().as_str());
            }
        }

        create_alter_section.push_str("\n/* ---> Enums: End --------------- */\n\n");
        if self.use_drop && !drop_section.is_empty() {
            drop_section.push_str("\n/* ---> Enums: Drop section end --------------- */\n\n");
        }

        if !create_alter_section.trim().is_empty() {
            self.enum_pre_script.push_str(&create_alter_section);
        }
        if self.use_drop && !drop_section.is_empty() {
            self.enum_post_script.push_str(&drop_section);
        }
        Ok(())
    }

    // Comparing sequences
    async fn compare_sequences(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Sequences: Start section --------------- */\n\n");

        // We will find all new sequences from "to" dump that are not in "from" dump
        // and we will find all existing sequences in both dumps with different hashes
        // and add them to the script.
        for sequence in &self.to.sequences {
            if let Some(from_sequence) = self
                .from
                .sequences
                .iter()
                .find(|s| s.name == sequence.name && s.schema == sequence.schema)
            {
                if from_sequence.hash() != sequence.hash() {
                    self.script.push_str(
                        format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                    );
                    self.script.push_str(sequence.get_alter_script().as_str());
                }
            } else {
                self.script.push_str(
                    format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                );
                self.script.push_str(sequence.get_script().as_str());
            }
        }

        for sequence in &self.from.sequences {
            if let Some(_to_sequence) = self
                .to
                .sequences
                .iter()
                .find(|s| s.name == sequence.name && s.schema == sequence.schema)
            {
                continue; // Sequence is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script.push_str(
                    format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                );
                self.script.push_str(
                    "/* Sequence is not present in 'to' dump and should be dropped. */\n",
                );
                self.script.push_str(sequence.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> Sequences: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing routines
    async fn compare_routines(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Routines: Start section --------------- */\n\n");

        // We will find all new routines from "to" dump that are not in "from" dump
        // and we will find all existing routines in both dumps with different hashes
        // and add them to the script.
        for routine in &self.to.routines {
            if let Some(from_routine) = self
                .from
                .routines
                .iter()
                .find(|r| r.name == routine.name && r.schema == routine.schema)
            {
                if from_routine.hash() != routine.hash() {
                    self.script.push_str(
                        format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                    );
                    self.script.push_str(routine.get_script().as_str());
                }
            } else {
                self.script.push_str(
                    format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                );
                self.script.push_str(routine.get_script().as_str());
            }
        }

        for routine in &self.from.routines {
            if let Some(_to_routine) = self
                .to
                .routines
                .iter()
                .find(|r| r.name == routine.name && r.schema == routine.schema)
            {
                continue; // Routine is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script.push_str(
                    format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                );
                self.script
                    .push_str("/* Routine is not present in 'to' dump and should be dropped. */\n");
                self.script.push_str(routine.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> Routines: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing tables
    async fn compare_tables(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Tables: Start section --------------- */\n\n");
        // We will drop all tables that exists just in "from" dump.
        for table in &self.from.tables {
            if let Some(_to_table) = self
                .to
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                continue; // Table is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str());
                self.script
                    .push_str("/* Table is not present in 'to' dump and should be dropped. */\n");
                self.script.push_str(table.get_drop_script().as_str());
            }
        }
        // We will find all new tables from "to" dump that are not in "from" dump
        // and add them to the script.
        for table in &self.to.tables {
            if let Some(from_table) = self
                .from
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if from_table.hash() != table.hash() {
                    // Just create an alter script for the table
                    // Will be added in next comparision (below)
                }
            } else {
                self.script
                    .push_str(format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str());
                self.script.push_str(table.get_script().as_str());
            }
        }
        // We will find all existing tables in both dumps with different hashes
        for table in &self.from.tables {
            if let Some(to_table) = self
                .to
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if to_table.hash() != table.hash() {
                    self.script.push_str(
                        format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str(),
                    );
                    self.script
                        .push_str(table.get_alter_script(to_table).as_str());
                }
            } else {
                continue; // Table is present in both dumps, we already processed it
            }
        }
        self.script
            .push_str("\n/* ---> Tables: End section --------------- */\n\n");
        Ok(())
    }

    // Drop existing in FROM dump views
    async fn drop_views(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Views DROP: Start section --------------- */\n\n");

        let dependent_views = self.dependent_view_keys();
        self.dropped_views.clear();

        // Drop views that are referenced by table columns in the source dump and exist in the target dump.
        for from_view in &self.from.views {
            let normalized_view = Self::normalized_view_key(&from_view.schema, &from_view.name);

            if dependent_views.contains(&normalized_view) {
                self.script.push_str(
                    format!("/* View: {}.{}*/\n", from_view.schema, from_view.name).as_str(),
                );
                self.script.push_str(from_view.get_drop_script().as_str());
                self.dropped_views.insert(normalized_view);
            }
        }

        self.script
            .push_str("\n/* ---> Views DROP: End section --------------- */\n\n");
        Ok(())
    }

    // Create views from TO dump
    async fn create_views(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Views CREATE: Start section --------------- */\n\n");

        for to_view in &self.to.views {
            let normalized_view = Self::normalized_view_key(&to_view.schema, &to_view.name);
            let existed_in_from = self
                .from
                .views
                .iter()
                .any(|view| view.schema == to_view.schema && view.name == to_view.name);

            if existed_in_from && !self.dropped_views.contains(&normalized_view) {
                continue;
            }

            self.script
                .push_str(format!("/* View: {}.{}*/\n", to_view.schema, to_view.name).as_str());

            let mut view_script = to_view.get_script();
            if !view_script
                .to_uppercase()
                .contains("CREATE OR REPLACE VIEW")
            {
                const TARGET: &str = "create view";
                const REPLACEMENT: &str = "CREATE OR REPLACE VIEW";

                if let Some(pos) = view_script.to_ascii_lowercase().find(TARGET) {
                    view_script.replace_range(pos..pos + TARGET.len(), REPLACEMENT);
                }
            }

            self.script.push_str(&view_script);
        }

        self.script
            .push_str("\n/* ---> Views CREATE: End section --------------- */\n\n");
        Ok(())
    }
}
