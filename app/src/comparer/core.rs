use crate::dump::core::Dump;
use std::{
    fs::File,
    io::{Error, Write},
};

// This is a Dump comparer that generates a script comparing two PostgreSQL dumps.
// The result script, if it will be applied on "from" dump database, will make it equal to "to" dump database.
pub struct Comparer {
    // The dump to compare from
    from: Dump,
    // The dump to compare to
    to: Dump,
    // Whether to use DROP statements in the output
    use_drop: bool,

    // The script that will be generated
    script: String,
}

impl Comparer {
    // Creates a new Comparer with the given dumps
    pub fn new(from: Dump, to: Dump, use_drop: bool) -> Self {
        let mut comparer = Self {
            from,
            to,
            use_drop,
            script: String::new(),
        };

        comparer.script.push_str("/*\n");
        comparer
            .script
            .push_str("Script generated by PostgreSQL Comparer\n\n");
        comparer.script.push_str(" From dump:\n");
        comparer.script.push_str(&comparer.from.get_info());
        comparer.script.push_str("\n\n To dump:\n");
        comparer.script.push_str(&comparer.to.get_info());
        comparer.script.push_str(&format!(
            "\n\n Comparison results (use_drop: {}):\n",
            comparer.use_drop
        ));
        comparer.script.push_str("*/\n\n");

        comparer
    }

    // Compare dumps and generate the script
    pub async fn compare(&mut self) -> Result<(), Error> {
        self.compare_schemas().await?;
        self.compare_extensions().await?;
        self.compare_types().await?;
        self.compare_enums().await?;
        self.compare_sequences().await?;
        self.drop_views().await?;
        self.compare_tables().await?;
        self.create_views().await?;
        self.compare_routines().await?;

        Ok(())
    }

    // Returns the script generated by the comparer
    fn get_script(&self) -> String {
        self.script.clone()
    }

    // Saves the generated script to a file
    pub async fn save_script(&self, output: &str) -> Result<(), Error> {
        let mut file = File::create(output)?;
        file.write_all(self.get_script().as_bytes())?;
        Ok(())
    }

    async fn compare_schemas(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Schemas: Start section --------------- */\n\n");

        // We will find all new schemas from "to" dump that are not in "from" dump
        // and add them to the script.
        for schema in &self.to.schemas {
            if let Some(_from_schema) = self.from.schemas.iter().find(|s| s.name == schema.name) {
                continue; // Schema is present in both dumps, we already processed it
            } else {
                self.script
                    .push_str(format!("\n/* Schema: {}*/\n", schema.name).as_str());
                self.script.push_str(schema.get_script().as_str());
            }
        }

        // We will find all schemas that exists just in "from" dump.
        // Drop will be added just if use_drop is true
        // TODO: We need to drop schema only if it's empty (no objects inside) Maybe the best way is to just skip dropping.
        /*
        for schema in &self.from.schemas {
            if let Some(_to_schema) = self
                .to
                .schemas
                .iter()
                .find(|s| s.name == schema.name)
            {
                continue; // Schema is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Schema: {}*/
\n", schema.name).as_str());
                self.script.push_str(
        " /* Schema is not present in 'to' dump and should be dropped. */
\n",
                );
                self.script.push_str(schema.get_drop_script().as_str());
            }
        }*/

        self.script
            .push_str("\n/* ---> Schemas: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing extentions
    async fn compare_extensions(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Extensions: Start section --------------- */\n\n");

        // We will find all new extensions from "to" dump that are not in "from" dump
        // and add them to the script.
        // Also we will find only in "from" dump extensions that are not in "to" dump and drop them.
        for ext in &self.to.extensions {
            if let Some(_from_ext) = self
                .from
                .extensions
                .iter()
                .find(|r| r.name == ext.name && r.schema == ext.schema)
            {
                continue; // Extension is present in both dumps, we already processed it
            } else {
                self.script
                    .push_str(format!("/* Extension: {}.{}*/\n", ext.schema, ext.name).as_str());
                self.script.push_str(ext.get_script().as_str());
            }
        }

        for ext in &self.from.extensions {
            if let Some(_to_ext) = self
                .to
                .extensions
                .iter()
                .find(|r| r.name == ext.name && r.schema == ext.schema)
            {
                continue; // Routine is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Extension: {}.{}*/\n", ext.schema, ext.name).as_str());
                self.script.push_str(
                    "/* Extension is not present in 'to' dump and should be dropped. */\n",
                );
                self.script.push_str(ext.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> Extensions: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing types
    async fn compare_types(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> User-defined types --------------- */\n\n");
        Ok(())
    }

    // Comparing enums
    async fn compare_enums(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Enums --------------- */\n\n");
        Ok(())
    }

    // Comparing sequences
    async fn compare_sequences(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Sequences: Start section --------------- */\n\n");

        // We will find all new sequences from "to" dump that are not in "from" dump
        // and we will find all existing sequences in both dumps with different hashes
        // and add them to the script.
        for sequence in &self.to.sequences {
            if let Some(from_sequence) = self
                .from
                .sequences
                .iter()
                .find(|s| s.name == sequence.name && s.schema == sequence.schema)
            {
                if from_sequence.hash() != sequence.hash() {
                    self.script.push_str(
                        format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                    );
                    self.script.push_str(sequence.get_alter_script().as_str());
                }
            } else {
                self.script.push_str(
                    format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                );
                self.script.push_str(sequence.get_script().as_str());
            }
        }

        for sequence in &self.from.sequences {
            if let Some(_to_sequence) = self
                .to
                .sequences
                .iter()
                .find(|s| s.name == sequence.name && s.schema == sequence.schema)
            {
                continue; // Sequence is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script.push_str(
                    format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                );
                self.script.push_str(
                    "/* Sequence is not present in 'to' dump and should be dropped. */\n",
                );
                self.script.push_str(sequence.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> Sequences: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing routines
    async fn compare_routines(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Routines: Start section --------------- */\n\n");

        // We will find all new routines from "to" dump that are not in "from" dump
        // and we will find all existing routines in both dumps with different hashes
        // and add them to the script.
        for routine in &self.to.routines {
            if let Some(from_routine) = self
                .from
                .routines
                .iter()
                .find(|r| r.name == routine.name && r.schema == routine.schema)
            {
                if from_routine.hash() != routine.hash() {
                    self.script.push_str(
                        format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                    );
                    self.script.push_str(routine.get_script().as_str());
                }
            } else {
                self.script.push_str(
                    format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                );
                self.script.push_str(routine.get_script().as_str());
            }
        }

        for routine in &self.from.routines {
            if let Some(_to_routine) = self
                .to
                .routines
                .iter()
                .find(|r| r.name == routine.name && r.schema == routine.schema)
            {
                continue; // Routine is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script.push_str(
                    format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                );
                self.script
                    .push_str("/* Routine is not present in 'to' dump and should be dropped. */\n");
                self.script.push_str(routine.get_drop_script().as_str());
            }
        }

        self.script
            .push_str("\n/* ---> Routines: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing tables
    async fn compare_tables(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Tables: Start section --------------- */\n\n");
        // We will drop all tables that exists just in "from" dump.
        for table in &self.from.tables {
            if let Some(_to_table) = self
                .to
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                continue; // Table is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str());
                self.script
                    .push_str("/* Table is not present in 'to' dump and should be dropped. */\n");
                self.script.push_str(table.get_drop_script().as_str());
            }
        }
        // We will find all new tables from "to" dump that are not in "from" dump
        // and add them to the script.
        for table in &self.to.tables {
            if let Some(from_table) = self
                .from
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if from_table.hash() != table.hash() {
                    // Just create an alter script for the table
                    // Will be added in next comparision (below)
                }
            } else {
                self.script
                    .push_str(format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str());
                self.script.push_str(table.get_script().as_str());
            }
        }
        // We will find all existing tables in both dumps with different hashes
        for table in &self.from.tables {
            if let Some(to_table) = self
                .to
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if to_table.hash() != table.hash() {
                    self.script.push_str(
                        format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str(),
                    );
                    self.script
                        .push_str(table.get_alter_script(to_table).as_str());
                }
            } else {
                continue; // Table is present in both dumps, we already processed it
            }
        }
        self.script
            .push_str("\n/* ---> Tables: End section --------------- */\n\n");
        Ok(())
    }

    // Drop existing in FROM dump views
    async fn drop_views(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Views DROP: Start section --------------- */\n\n");

        // We will drop all views that exists in "from" dump.
        for from_view in &self.from.views {
            self.script
                .push_str(format!("/* View: {}.{}*/\n", from_view.schema, from_view.name).as_str());
            self.script.push_str(from_view.get_drop_script().as_str());
        }

        self.script
            .push_str("\n/* ---> Views DROP: End section --------------- */\n\n");
        Ok(())
    }

    // Create views from TO dump
    async fn create_views(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Views CREATE: Start section --------------- */\n\n");

        // We will create all views that exists in "to" dump.
        for to_view in &self.to.views {
            self.script
                .push_str(format!("/* View: {}.{}*/\n", to_view.schema, to_view.name).as_str());
            self.script.push_str(to_view.get_script().as_str());
        }

        self.script
            .push_str("\n/* ---> Views CREATE: End section --------------- */\n\n");
        Ok(())
    }
}
