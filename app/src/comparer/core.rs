use crate::dump::{core::Dump, routine::Routine};
use std::{
    collections::HashSet,
    fs::File,
    io::{Error, Write},
};

// This is a Dump comparer that generates a script comparing two PostgreSQL dumps.
// The result script, if it will be applied on "from" dump database, will make it equal to "to" dump database.
pub struct Comparer {
    // The dump to compare from
    from: Dump,
    // The dump to compare to
    to: Dump,
    // Whether to use DROP statements in the output
    use_drop: bool,

    // The script that will be generated
    script: String,
    enum_pre_script: String,
    enum_post_script: String,
    sequence_post_script: String,
    dropped_views: HashSet<String>,
}

impl Comparer {
    // Creates a new Comparer with the given dumps
    pub fn new(from: Dump, to: Dump, use_drop: bool) -> Self {
        let mut comparer = Self {
            from,
            to,
            use_drop,
            script: String::new(),
            enum_pre_script: String::new(),
            enum_post_script: String::new(),
            sequence_post_script: String::new(),
            dropped_views: HashSet::new(),
        };

        comparer.script.push_str("/*\n");
        comparer
            .script
            .push_str("Script generated by PostgreSQL Comparer\n\n");
        comparer.script.push_str(" From dump:\n");
        comparer.script.push_str(&comparer.from.get_info());
        comparer.script.push_str("\n\n To dump:\n");
        comparer.script.push_str(&comparer.to.get_info());
        comparer.script.push_str(&format!(
            "\n\n Comparison results (use_drop: {}):\n",
            comparer.use_drop
        ));
        comparer.script.push_str("*/\n\n");

        comparer
    }

    // Compare dumps and generate the script
    pub async fn compare(&mut self) -> Result<(), Error> {
        self.compare_schemas().await?;
        self.compare_extensions().await?;
        self.compare_enums().await?;
        if !self.enum_pre_script.is_empty() {
            self.script.push_str(&self.enum_pre_script);
            self.enum_pre_script.clear();
        }
        self.compare_types().await?;
        // The order of operations here is important due to dependency relationships:
        // - Tables may depend on sequences (e.g., via SERIAL columns).
        // - Sequences may depend on tables (e.g., via ownership).
        // Therefore, we compare sequences and drop views before comparing tables,
        // and defer sequence drops until after tables to avoid dependency errors.
        self.compare_sequences().await?;
        self.drop_views().await?;
        self.compare_tables().await?;
        self.compare_foreign_keys().await?;
        if !self.enum_post_script.is_empty() {
            self.script.push_str(&self.enum_post_script);
            self.enum_post_script.clear();
        }
        if !self.sequence_post_script.is_empty() {
            self.script.push_str(&self.sequence_post_script);
            self.sequence_post_script.clear();
        }
        self.create_views().await?;
        self.compare_routines().await?;

        Ok(())
    }

    #[inline]
    fn hashes_differ(a: &Option<String>, b: &Option<String>) -> bool {
        match (a, b) {
            (Some(lhs), Some(rhs)) => lhs != rhs,
            (Some(_), None) | (None, Some(_)) => true,
            (None, None) => false,
        }
    }

    fn process_target_routine(&mut self, routine: &Routine) {
        if routine.hash.is_none() {
            self.script.push_str(
                format!(
                    "/* Skipping routine {}.{} due to missing hash. */\n",
                    routine.schema, routine.name
                )
                .as_str(),
            );
            return;
        }

        if let Some(from_routine) = self
            .from
            .routines
            .iter()
            .find(|r| r.name == routine.name && r.schema == routine.schema)
        {
            if from_routine.hash.is_none() {
                self.script.push_str(
                    format!(
                        "/* Skipping routine {}.{} due to missing hash. */\n",
                        from_routine.schema, from_routine.name
                    )
                    .as_str(),
                );
                return;
            }

            if Self::hashes_differ(&from_routine.hash, &routine.hash) {
                if from_routine.return_type != routine.return_type
                    || from_routine.arguments != routine.arguments
                {
                    let drop_script = from_routine.get_drop_script();
                    if self.use_drop {
                        self.script.push_str(drop_script.as_str());
                    } else {
                        self.script.push_str(
                            drop_script
                                .lines()
                                .map(|l| format!("-- {}\n", l))
                                .collect::<String>()
                                .as_str(),
                        );
                    }
                }
                self.script.push_str(
                    format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                );
                self.script.push_str(routine.get_script().as_str());
            }
        } else {
            self.script
                .push_str(format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str());
            self.script.push_str(routine.get_script().as_str());
        }
    }

    // Returns the script generated by the comparer
    fn get_script(&self) -> String {
        self.script.clone()
    }

    fn normalized_view_reference(reference: &str) -> String {
        reference
            .trim()
            .chars()
            .filter(|c| !matches!(c, '"' | '\'' | '`'))
            .collect::<String>()
            .to_lowercase()
    }

    fn normalized_view_key(schema: &str, name: &str) -> String {
        Self::normalized_view_reference(format!("{}.{}", schema, name).as_str())
    }

    fn dependent_view_keys(&self) -> HashSet<String> {
        let mut dependent_views = HashSet::new();

        for table in &self.from.tables {
            let matching_table = self
                .to
                .tables
                .iter()
                .find(|t| t.schema == table.schema && t.name == table.name);

            let will_be_dropped = matching_table.is_none() && self.use_drop;
            let will_be_altered = matching_table
                .map(|target| Self::hashes_differ(&target.hash, &table.hash))
                .unwrap_or(false);

            if !will_be_dropped && !will_be_altered {
                continue;
            }

            for column in &table.columns {
                if let Some(related_views) = &column.related_views {
                    for view_ref in related_views {
                        let normalized = Self::normalized_view_reference(view_ref);
                        if !normalized.is_empty() {
                            dependent_views.insert(normalized);
                        }
                    }
                }
            }
        }

        dependent_views
    }

    // Saves the generated script to a file
    pub async fn save_script(&self, output: &str) -> Result<(), Error> {
        let mut file = File::create(output)?;
        file.write_all(self.get_script().as_bytes())?;
        Ok(())
    }

    async fn compare_schemas(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Schemas: Start section --------------- */\n\n");

        // We will find all new schemas from "to" dump that are not in "from" dump
        // and add them to the script.
        for schema in &self.to.schemas {
            if let Some(_from_schema) = self.from.schemas.iter().find(|s| s.name == schema.name) {
                continue; // Schema is present in both dumps, we already processed it
            } else {
                self.script
                    .push_str(format!("\n/* Schema: {}*/\n", schema.name).as_str());
                self.script.push_str(schema.get_script().as_str());
            }
        }

        // We will find all schemas that exists just in "from" dump.
        // Drop will be added just if use_drop is true
        // TODO: We need to drop schema only if it's empty (no objects inside) Maybe the best way is to just skip dropping.
        /*
        for schema in &self.from.schemas {
            if let Some(_to_schema) = self
                .to
                .schemas
                .iter()
                .find(|s| s.name == schema.name)
            {
                continue; // Schema is present in both dumps, we already processed it
            } else if self.use_drop {
                // Just if we're using DROP statements
                self.script
                    .push_str(format!("/* Schema: {}*/
\n", schema.name).as_str());
                self.script.push_str(
        " /* Schema is not present in 'to' dump and should be dropped. */
\n",
                );
                self.script.push_str(schema.get_drop_script().as_str());
            }
        }*/

        self.script
            .push_str("\n/* ---> Schemas: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing extentions
    async fn compare_extensions(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Extensions: Start section --------------- */\n\n");

        // We will find all new extensions from "to" dump that are not in "from" dump
        // and add them to the script.
        // Also we will find only in "from" dump extensions that are not in "to" dump and drop them.
        for ext in &self.to.extensions {
            if let Some(_from_ext) = self
                .from
                .extensions
                .iter()
                .find(|r| r.name == ext.name && r.schema == ext.schema)
            {
                continue; // Extension is present in both dumps, we already processed it
            } else {
                self.script
                    .push_str(format!("/* Extension: {}.{}*/\n", ext.schema, ext.name).as_str());
                self.script.push_str(ext.get_script().as_str());
            }
        }

        for ext in &self.from.extensions {
            if let Some(_to_ext) = self
                .to
                .extensions
                .iter()
                .find(|r| r.name == ext.name && r.schema == ext.schema)
            {
                continue; // Routine is present in both dumps, we already processed it
            } else {
                // Extension is not present in 'to' dump and should be dropped.
                self.script
                    .push_str(format!("/* Extension: {}.{}*/\n", ext.schema, ext.name).as_str());
                self.script.push_str(
                    "/* Extension is not present in 'to' dump and should be dropped. */\n",
                );

                let drop_script = ext.get_drop_script();
                if self.use_drop {
                    self.script.push_str(drop_script.as_str());
                } else {
                    self.script.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
            }
        }

        self.script
            .push_str("\n/* ---> Extensions: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing types
    async fn compare_types(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> User-defined types: Start --------------- */\n\n");

        for to_type in &self.to.types {
            if (to_type.typtype as u8 as char) == 'e' {
                continue;
            }
            if let Some(from_type) = self
                .from
                .types
                .iter()
                .find(|t| t.schema == to_type.schema && t.typname == to_type.typname)
            {
                if Self::hashes_differ(&from_type.hash, &to_type.hash) {
                    self.script.push_str(
                        format!("/* Type: {}.{} */\n", to_type.schema, to_type.typname).as_str(),
                    );
                    let alter_script = from_type.get_alter_script(to_type);
                    if alter_script.trim().is_empty() {
                        self.script.push_str(
                            "-- No supported alterations for this type; manual review required.\n",
                        );
                    } else {
                        self.script.push_str(alter_script.as_str());
                    }
                }
            } else {
                self.script.push_str(
                    format!("/* Type: {}.{} */\n", to_type.schema, to_type.typname).as_str(),
                );
                self.script.push_str(to_type.get_script().as_str());
            }
        }

        {
            for from_type in &self.from.types {
                if (from_type.typtype as u8 as char) == 'e' {
                    continue;
                }
                if self
                    .to
                    .types
                    .iter()
                    .any(|t| t.schema == from_type.schema && t.typname == from_type.typname)
                {
                    continue;
                }

                self.script.push_str(
                    format!("/* Type: {}.{} */\n", from_type.schema, from_type.typname).as_str(),
                );
                self.script
                    .push_str("/* Type is not present in 'to' dump and should be dropped. */\n");

                let drop_script = from_type.get_drop_script();
                if self.use_drop {
                    self.script.push_str(drop_script.as_str());
                } else {
                    self.script.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
            }
        }

        self.script
            .push_str("\n/* ---> User-defined types: End --------------- */\n\n");
        Ok(())
    }

    // Comparing enums
    async fn compare_enums(&mut self) -> Result<(), Error> {
        let mut create_alter_section = String::new();
        create_alter_section.push_str("\n/* ---> Enums: Start --------------- */\n\n");

        let mut drop_section = String::new();

        let to_enums = self
            .to
            .types
            .iter()
            .filter(|t| (t.typtype as u8 as char) == 'e');

        for to_enum in to_enums {
            if to_enum.hash.is_none() {
                self.script.push_str(
                    format!(
                        "/* Skipping enum {}.{} due to missing hash. */\n",
                        to_enum.schema, to_enum.typname
                    )
                    .as_str(),
                );
                continue;
            }
            if let Some(from_enum) = self
                .from
                .types
                .iter()
                .find(|t| t.schema == to_enum.schema && t.typname == to_enum.typname)
            {
                if from_enum.hash.is_none() {
                    self.script.push_str(
                        format!(
                            "/* Skipping enum {}.{} due to missing hash. */\n",
                            from_enum.schema, from_enum.typname
                        )
                        .as_str(),
                    );
                    continue;
                }
                if Self::hashes_differ(&from_enum.hash, &to_enum.hash) {
                    create_alter_section.push_str(
                        format!("/* Enum: {}.{} */\n", to_enum.schema, to_enum.typname).as_str(),
                    );
                    let alter_script = from_enum.get_alter_script(to_enum);
                    if alter_script.trim().is_empty() {
                        create_alter_section.push_str(
                            "-- No supported alterations for this enum; manual review required.\n",
                        );
                    } else {
                        create_alter_section.push_str(alter_script.as_str());
                    }
                }
            } else {
                create_alter_section.push_str(
                    format!("/* Enum: {}.{} */\n", to_enum.schema, to_enum.typname).as_str(),
                );
                create_alter_section.push_str(to_enum.get_script().as_str());
            }
        }

        {
            for from_enum in self
                .from
                .types
                .iter()
                .filter(|t| (t.typtype as u8 as char) == 'e')
            {
                if self
                    .to
                    .types
                    .iter()
                    .any(|t| t.schema == from_enum.schema && t.typname == from_enum.typname)
                {
                    continue;
                }

                if drop_section.is_empty() {
                    drop_section.push_str(
                        "\n/* ---> Enums: Drop section (execute after dependent types) --------------- */\n\n",
                    );
                }
                drop_section.push_str(
                    format!("/* Enum: {}.{} */\n", from_enum.schema, from_enum.typname).as_str(),
                );
                drop_section
                    .push_str("/* Enum is not present in 'to' dump and should be dropped. */\n");

                let drop_script = from_enum.get_drop_script();
                if self.use_drop {
                    drop_section.push_str(drop_script.as_str());
                } else {
                    drop_section.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
            }
        }

        create_alter_section.push_str("\n/* ---> Enums: End --------------- */\n\n");
        if !drop_section.is_empty() {
            drop_section.push_str("\n/* ---> Enums: Drop section end --------------- */\n\n");
        }

        if !create_alter_section.trim().is_empty() {
            self.enum_pre_script.push_str(&create_alter_section);
        }
        if !drop_section.is_empty() {
            self.enum_post_script.push_str(&drop_section);
        }
        Ok(())
    }

    // Comparing sequences
    async fn compare_sequences(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Sequences: Start section --------------- */\n\n");

        let mut drop_section = String::new();

        // We will find all new sequences from "to" dump that are not in "from" dump
        // and we will find all existing sequences in both dumps with different hashes
        // and add them to the script.
        for sequence in &self.to.sequences {
            if sequence.hash.is_none() {
                self.script.push_str(
                    format!(
                        "/* Skipping sequence {}.{} due to missing hash. */\n",
                        sequence.schema, sequence.name
                    )
                    .as_str(),
                );
                continue;
            }
            if let Some(from_sequence) = self
                .from
                .sequences
                .iter()
                .find(|s| s.name == sequence.name && s.schema == sequence.schema)
            {
                if from_sequence.hash.is_none() {
                    self.script.push_str(
                        format!(
                            "/* Skipping sequence {}.{} due to missing hash. */\n",
                            from_sequence.schema, from_sequence.name
                        )
                        .as_str(),
                    );
                    continue;
                }
                if Self::hashes_differ(&from_sequence.hash, &sequence.hash) {
                    self.script.push_str(
                        format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                    );
                    self.script.push_str(sequence.get_alter_script().as_str());
                }
            } else {
                // Check if the sequence is owned by a column that is an identity column or serial type.
                // In this case, the sequence is created automatically by PostgreSQL when the table/column is created.
                if let (Some(schema), Some(table), Some(column)) = (
                    &sequence.owned_by_schema,
                    &sequence.owned_by_table,
                    &sequence.owned_by_column,
                ) && let Some(to_table) = self
                    .to
                    .tables
                    .iter()
                    .find(|t| t.schema == *schema && t.name == *table)
                    && let Some(to_column) = to_table.columns.iter().find(|c| c.name == *column)
                {
                    let is_identity = to_column.is_identity;
                    let is_serial = to_column.data_type.to_lowercase().contains("serial");

                    if is_identity || is_serial {
                        self.script.push_str(
                                    format!(
                                        "/* Skipping sequence {}.{} as it will be created by column {}.{}.{} (identity/serial) */\n",
                                        sequence.schema, sequence.name, schema, table, column
                                    )
                                    .as_str(),
                                );
                        continue;
                    }
                }

                self.script.push_str(
                    format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                );
                self.script.push_str(sequence.get_script().as_str());
            }
        }

        {
            let mut dropped_sequences = HashSet::new();
            for sequence in &self.from.sequences {
                if dropped_sequences.contains(&format!("{}.{}", sequence.schema, sequence.name)) {
                    continue;
                }

                if let Some(_to_sequence) = self
                    .to
                    .sequences
                    .iter()
                    .find(|s| s.name == sequence.name && s.schema == sequence.schema)
                {
                    continue; // Sequence is present in both dumps, we already processed it
                }

                // Check if the sequence is owned by a table/column.
                if let (Some(schema), Some(table)) =
                    (&sequence.owned_by_schema, &sequence.owned_by_table)
                {
                    let to_table = self
                        .to
                        .tables
                        .iter()
                        .find(|t| t.schema == *schema && t.name == *table);

                    if to_table.is_none() {
                        self.script.push_str(
                            format!(
                                "/* Skipping drop of sequence {}.{} as it is owned by table {}.{} which will be dropped. */\n",
                                sequence.schema, sequence.name, schema, table
                            )
                            .as_str(),
                        );
                        continue;
                    }

                    // Table exists in TO. Check if column exists or if it was an identity column.
                    if let Some(column_name) = &sequence.owned_by_column {
                        let to_table = to_table.unwrap();
                        let to_column = to_table.columns.iter().find(|c| c.name == *column_name);

                        if to_column.is_none() {
                            self.script.push_str(
                                format!(
                                    "/* Skipping drop of sequence {}.{} as it is owned by column {}.{}.{} which will be dropped. */\n",
                                    sequence.schema, sequence.name, schema, table, column_name
                                )
                                .as_str(),
                            );
                            continue;
                        }

                        // Column exists in TO. Check if it was an identity column in FROM.
                        if let Some(from_table) = self
                            .from
                            .tables
                            .iter()
                            .find(|t| t.schema == *schema && t.name == *table)
                            && let Some(from_column) =
                                from_table.columns.iter().find(|c| c.name == *column_name)
                            && from_column.is_identity
                        {
                            self.script.push_str(
                                        format!(
                                            "/* Skipping drop of sequence {}.{} as it is owned by identity column {}.{}.{}. */\n",
                                            sequence.schema, sequence.name, schema, table, column_name
                                        )
                                        .as_str(),
                                    );
                            continue;
                        }
                    }
                }

                if drop_section.is_empty() {
                    drop_section.push_str(
                        "\n/* ---> Sequences: Drop section (execute after dependent tables) --------------- */\n\n",
                    );
                }

                drop_section.push_str(
                    format!("/* Sequence: {}.{}*/\n", sequence.schema, sequence.name).as_str(),
                );
                drop_section.push_str(
                    "/* Sequence is not present in 'to' dump and should be dropped. */\n",
                );

                let drop_script = sequence.get_drop_script();
                if self.use_drop {
                    drop_section.push_str(drop_script.as_str());
                } else {
                    drop_section.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
                dropped_sequences.insert(format!("{}.{}", sequence.schema, sequence.name));
            }
        }

        self.script
            .push_str("\n/* ---> Sequences: End section --------------- */\n\n");

        if !drop_section.is_empty() {
            drop_section.push_str("\n/* ---> Sequences: Drop section end --------------- */\n\n");
            self.sequence_post_script.push_str(&drop_section);
        }
        Ok(())
    }

    // Comparing routines
    async fn compare_routines(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Routines: Start section --------------- */\n\n");

        // Apply non-SQL routines first, then SQL routines last.
        let (sql_routines, other_routines): (Vec<_>, Vec<_>) = self
            .to
            .routines
            .iter()
            .cloned()
            .partition(|r| r.lang.eq_ignore_ascii_case("sql"));

        for routine in &other_routines {
            self.process_target_routine(routine);
        }

        for routine in &sql_routines {
            self.process_target_routine(routine);
        }

        for routine in &self.from.routines {
            if let Some(_to_routine) = self
                .to
                .routines
                .iter()
                .find(|r| r.name == routine.name && r.schema == routine.schema)
            {
                continue; // Routine is present in both dumps, we already processed it
            } else {
                // Routine is not present in 'to' dump and should be dropped.
                self.script.push_str(
                    format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str(),
                );
                self.script
                    .push_str("/* Routine is not present in 'to' dump and should be dropped. */\n");

                let drop_script = routine.get_drop_script();
                if self.use_drop {
                    self.script.push_str(drop_script.as_str());
                } else {
                    self.script.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
            }
        }

        self.script
            .push_str("\n/* ---> Routines: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing tables
    async fn compare_tables(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Tables: Start section --------------- */\n\n");
        // We will drop all tables that exists just in "from" dump.
        for table in &self.from.tables {
            if let Some(_to_table) = self
                .to
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                continue; // Table is present in both dumps, we already processed it
            } else {
                // Table is not present in 'to' dump and should be dropped.
                self.script
                    .push_str(format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str());
                self.script
                    .push_str("/* Table is not present in 'to' dump and should be dropped. */\n");

                let drop_script = table.get_drop_script();
                if self.use_drop {
                    self.script.push_str(drop_script.as_str());
                } else {
                    self.script.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
            }
        }
        // We will find all new tables from "to" dump that are not in "from" dump
        // and add them to the script.
        for table in &self.to.tables {
            if table.hash.is_none() {
                self.script.push_str(
                    format!(
                        "/* Skipping table {}.{} due to missing hash. */\n",
                        table.schema, table.name
                    )
                    .as_str(),
                );
                continue;
            }
            if let Some(from_table) = self
                .from
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if from_table.hash.is_none() {
                    self.script.push_str(
                        format!(
                            "/* Skipping table {}.{} due to missing hash. */\n",
                            from_table.schema, from_table.name
                        )
                        .as_str(),
                    );
                    continue;
                }
                if Self::hashes_differ(&from_table.hash, &table.hash) {
                    // Just create an alter script for the table
                    // Will be added in next comparision (below)
                }
            } else {
                self.script
                    .push_str(format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str());
                self.script.push_str(table.get_script().as_str());
            }
        }
        // We will find all existing tables in both dumps with different hashes
        for table in &self.from.tables {
            if table.hash.is_none() {
                self.script.push_str(
                    format!(
                        "/* Skipping table {}.{} due to missing hash. */\n",
                        table.schema, table.name
                    )
                    .as_str(),
                );
                continue;
            }
            if let Some(to_table) = self
                .to
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if to_table.hash.is_none() {
                    self.script.push_str(
                        format!(
                            "/* Skipping table {}.{} due to missing hash. */\n",
                            to_table.schema, to_table.name
                        )
                        .as_str(),
                    );
                    continue;
                }
                if Self::hashes_differ(&to_table.hash, &table.hash) {
                    self.script.push_str(
                        format!("/* Table: {}.{}*/\n", table.schema, table.name).as_str(),
                    );
                    self.script
                        .push_str(table.get_alter_script(to_table, self.use_drop).as_str());
                }
            } else {
                continue; // Table is present in both dumps, we already processed it
            }
        }
        self.script
            .push_str("\n/* ---> Tables: End section --------------- */\n\n");
        Ok(())
    }

    // Comparing foreign keys
    async fn compare_foreign_keys(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Foreign Keys: Start section --------------- */\n\n");

        for table in &self.to.tables {
            if table.hash.is_none() {
                continue;
            }

            if let Some(from_table) = self
                .from
                .tables
                .iter()
                .find(|t| t.name == table.name && t.schema == table.schema)
            {
                if from_table.hash.is_none() {
                    continue;
                }

                // Table exists in both. Check for FK changes.
                self.script
                    .push_str(&from_table.get_foreign_key_alter_script(table));
            } else {
                // New table. Add its FKs.
                self.script.push_str(&table.get_foreign_key_script());
            }
        }

        self.script
            .push_str("\n/* ---> Foreign Keys: End section --------------- */\n\n");
        Ok(())
    }

    // Drop existing in FROM dump views
    async fn drop_views(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Views DROP: Start section --------------- */\n\n");

        let dependent_views = self.dependent_view_keys();
        self.dropped_views.clear();

        // Drop views that are referenced by table columns in the source dump and exist in the target dump.
        for from_view in &self.from.views {
            let normalized_view = Self::normalized_view_key(&from_view.schema, &from_view.name);

            if dependent_views.contains(&normalized_view) {
                self.script.push_str(
                    format!("/* View: {}.{}*/\n", from_view.schema, from_view.name).as_str(),
                );

                let drop_script = from_view.get_drop_script();
                if self.use_drop {
                    self.script.push_str(drop_script.as_str());
                } else {
                    self.script.push_str(
                        drop_script
                            .lines()
                            .map(|l| format!("-- {}\n", l))
                            .collect::<String>()
                            .as_str(),
                    );
                }
                self.dropped_views.insert(normalized_view);
            }
        }

        self.script
            .push_str("\n/* ---> Views DROP: End section --------------- */\n\n");
        Ok(())
    }

    // Create views from TO dump
    async fn create_views(&mut self) -> Result<(), Error> {
        self.script
            .push_str("\n/* ---> Views CREATE: Start section --------------- */\n\n");

        for to_view in &self.to.views {
            let normalized_view = Self::normalized_view_key(&to_view.schema, &to_view.name);
            let existed_in_from = self
                .from
                .views
                .iter()
                .any(|view| view.schema == to_view.schema && view.name == to_view.name);

            if existed_in_from && !self.dropped_views.contains(&normalized_view) {
                continue;
            }

            self.script
                .push_str(format!("/* View: {}.{}*/\n", to_view.schema, to_view.name).as_str());

            let mut view_script = to_view.get_script();
            if !view_script
                .to_uppercase()
                .contains("CREATE OR REPLACE VIEW")
            {
                const TARGET: &str = "create view";
                const REPLACEMENT: &str = "CREATE OR REPLACE VIEW";

                if let Some(pos) = view_script.to_ascii_lowercase().find(TARGET) {
                    view_script.replace_range(pos..pos + TARGET.len(), REPLACEMENT);
                }
            }

            self.script.push_str(&view_script);
        }

        self.script
            .push_str("\n/* ---> Views CREATE: End section --------------- */\n\n");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::dump_config::DumpConfig;
    use crate::dump::routine::Routine;
    use sqlx::postgres::types::Oid;

    #[tokio::test]
    async fn compare_routines_drops_and_recreates_on_return_type_change() {
        let mut from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        let from_routine = Routine::new(
            "public".to_string(),
            Oid(1),
            "test_func".to_string(),
            "plpgsql".to_string(),
            "FUNCTION".to_string(),
            "integer".to_string(),
            "".to_string(),
            None,
            "BEGIN RETURN 1; END".to_string(),
        );

        let to_routine = Routine::new(
            "public".to_string(),
            Oid(1),
            "test_func".to_string(),
            "plpgsql".to_string(),
            "FUNCTION".to_string(),
            "text".to_string(),
            "".to_string(),
            None,
            "BEGIN RETURN '1'; END".to_string(),
        );

        from_dump.routines.push(from_routine);
        to_dump.routines.push(to_routine);

        let mut comparer = Comparer::new(from_dump, to_dump, false);
        comparer.compare_routines().await.unwrap();
        let script = comparer.get_script();

        assert!(script.contains("drop function if exists \"public\".\"test_func\" ();"));
        assert!(
            script.contains("create or replace function \"public\".\"test_func\"() returns text")
        );
    }

    #[tokio::test]
    async fn compare_routines_drops_and_recreates_on_argument_change() {
        let mut from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        let from_routine = Routine::new(
            "public".to_string(),
            Oid(1),
            "test_func".to_string(),
            "plpgsql".to_string(),
            "FUNCTION".to_string(),
            "integer".to_string(),
            "a integer".to_string(),
            None,
            "BEGIN RETURN a; END".to_string(),
        );

        let to_routine = Routine::new(
            "public".to_string(),
            Oid(1),
            "test_func".to_string(),
            "plpgsql".to_string(),
            "FUNCTION".to_string(),
            "integer".to_string(),
            "a text".to_string(),
            None,
            "BEGIN RETURN 1; END".to_string(),
        );

        from_dump.routines.push(from_routine);
        to_dump.routines.push(to_routine);

        let mut comparer = Comparer::new(from_dump, to_dump, false);
        comparer.compare_routines().await.unwrap();
        let script = comparer.get_script();

        assert!(script.contains("drop function if exists \"public\".\"test_func\" (a integer);"));
        assert!(script.contains(
            "create or replace function \"public\".\"test_func\"(a text) returns integer"
        ));
    }

    #[tokio::test]
    async fn compare_routines_applies_sql_routines_last() {
        let from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        let plpgsql_routine = Routine::new(
            "public".to_string(),
            Oid(1),
            "fn_plpgsql".to_string(),
            "plpgsql".to_string(),
            "FUNCTION".to_string(),
            "integer".to_string(),
            "".to_string(),
            None,
            "BEGIN RETURN 1; END".to_string(),
        );

        let sql_routine = Routine::new(
            "public".to_string(),
            Oid(2),
            "fn_sql".to_string(),
            "sql".to_string(),
            "FUNCTION".to_string(),
            "integer".to_string(),
            "".to_string(),
            None,
            "SELECT 1;".to_string(),
        );

        // Intentionally add SQL first to ensure reordering happens.
        to_dump.routines.push(sql_routine);
        to_dump.routines.push(plpgsql_routine);

        let mut comparer = Comparer::new(from_dump, to_dump, false);
        comparer.compare_routines().await.unwrap();
        let script = comparer.get_script();

        let pos_plpgsql = script
            .find("create or replace function \"public\".\"fn_plpgsql\"")
            .expect("plpgsql routine script not found");
        let pos_sql = script
            .find("create or replace function \"public\".\"fn_sql\"")
            .expect("sql routine script not found");

        assert!(pos_plpgsql < pos_sql, "SQL routines should be applied last");
    }

    use crate::dump::sequence::Sequence;
    use crate::dump::table::Table;
    use crate::dump::table_column::TableColumn;

    #[tokio::test]
    async fn compare_sequences_skips_owned_by_serial_column() {
        let from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        // Sequence owned by table column
        let sequence = Sequence::new(
            "public".to_string(),
            "test_id_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(1),
            Some(1),
            Some(1000),
            Some(1),
            false,
            Some(1),
            Some(1),
            Some("public".to_string()),
            Some("test".to_string()),
            Some("id".to_string()),
        );
        to_dump.sequences.push(sequence);

        // Table with serial column
        let column = TableColumn {
            catalog: "postgres".to_string(),
            schema: "public".to_string(),
            table: "test".to_string(),
            name: "id".to_string(),
            ordinal_position: 1,
            column_default: Some("nextval('test_id_seq'::regclass)".to_string()),
            is_nullable: false,
            data_type: "bigserial".to_string(), // This triggers the skip
            character_maximum_length: None,
            character_octet_length: None,
            numeric_precision: Some(64),
            numeric_precision_radix: Some(2),
            numeric_scale: Some(0),
            datetime_precision: None,
            interval_type: None,
            interval_precision: None,
            character_set_catalog: None,
            character_set_schema: None,
            character_set_name: None,
            collation_catalog: None,
            collation_schema: None,
            collation_name: None,
            domain_catalog: None,
            domain_schema: None,
            domain_name: None,
            udt_catalog: None,
            udt_schema: None,
            udt_name: None,
            scope_catalog: None,
            scope_schema: None,
            scope_name: None,
            maximum_cardinality: None,
            dtd_identifier: None,
            is_self_referencing: false,
            is_identity: false,
            identity_generation: None,
            identity_start: None,
            identity_increment: None,
            identity_maximum: None,
            identity_minimum: None,
            identity_cycle: false,
            is_generated: "NEVER".to_string(),
            generation_expression: None,
            is_updatable: true,
            related_views: None,
        };

        let table = Table::new(
            "public".to_string(),
            "test".to_string(),
            "postgres".to_string(),
            None,
            vec![column],
            vec![],
            vec![],
            vec![],
            None,
        );
        to_dump.tables.push(table);

        let mut comparer = Comparer::new(from_dump, to_dump, false);
        comparer.compare_sequences().await.unwrap();
        let script = comparer.get_script();

        assert!(script.contains(
            "Skipping sequence public.test_id_seq as it will be created by column public.test.id"
        ));
        assert!(!script.contains("create sequence \"public\".\"test_id_seq\""));
    }

    #[tokio::test]
    async fn compare_sequences_skips_owned_by_identity_column() {
        let from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        // Sequence owned by table column
        let sequence = Sequence::new(
            "public".to_string(),
            "test_id_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(1),
            Some(1),
            Some(1000),
            Some(1),
            false,
            Some(1),
            Some(1),
            Some("public".to_string()),
            Some("test".to_string()),
            Some("id".to_string()),
        );
        to_dump.sequences.push(sequence);

        // Table with identity column
        let column = TableColumn {
            catalog: "postgres".to_string(),
            schema: "public".to_string(),
            table: "test".to_string(),
            name: "id".to_string(),
            ordinal_position: 1,
            column_default: None,
            is_nullable: false,
            data_type: "bigint".to_string(),
            character_maximum_length: None,
            character_octet_length: None,
            numeric_precision: Some(64),
            numeric_precision_radix: Some(2),
            numeric_scale: Some(0),
            datetime_precision: None,
            interval_type: None,
            interval_precision: None,
            character_set_catalog: None,
            character_set_schema: None,
            character_set_name: None,
            collation_catalog: None,
            collation_schema: None,
            collation_name: None,
            domain_catalog: None,
            domain_schema: None,
            domain_name: None,
            udt_catalog: None,
            udt_schema: None,
            udt_name: None,
            scope_catalog: None,
            scope_schema: None,
            scope_name: None,
            maximum_cardinality: None,
            dtd_identifier: None,
            is_self_referencing: false,
            is_identity: true, // This triggers the skip
            identity_generation: Some("ALWAYS".to_string()),
            identity_start: Some("1".to_string()),
            identity_increment: Some("1".to_string()),
            identity_maximum: None,
            identity_minimum: None,
            identity_cycle: false,
            is_generated: "NEVER".to_string(),
            generation_expression: None,
            is_updatable: true,
            related_views: None,
        };

        let table = Table::new(
            "public".to_string(),
            "test".to_string(),
            "postgres".to_string(),
            None,
            vec![column],
            vec![],
            vec![],
            vec![],
            None,
        );
        to_dump.tables.push(table);

        let mut comparer = Comparer::new(from_dump, to_dump, false);
        comparer.compare_sequences().await.unwrap();
        let script = comparer.get_script();

        assert!(script.contains(
            "Skipping sequence public.test_id_seq as it will be created by column public.test.id"
        ));
        assert!(!script.contains("create sequence \"public\".\"test_id_seq\""));
    }

    #[tokio::test]
    async fn compare_sequences_does_not_skip_normal_sequence() {
        let from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        // Normal sequence not owned by any column
        let sequence = Sequence::new(
            "public".to_string(),
            "test_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(1),
            Some(1),
            Some(1000),
            Some(1),
            false,
            Some(1),
            Some(1),
            None,
            None,
            None,
        );
        to_dump.sequences.push(sequence);

        let mut comparer = Comparer::new(from_dump, to_dump, false);
        comparer.compare_sequences().await.unwrap();
        let script = comparer.get_script();

        assert!(!script.contains("Skipping sequence"));
        assert!(script.contains("create sequence \"public\".\"test_seq\""));
    }

    #[tokio::test]
    async fn compare_sequences_skips_drop_if_owned_by_dropped_table() {
        let mut from_dump = Dump::new(DumpConfig::default());
        let to_dump = Dump::new(DumpConfig::default());

        // Sequence owned by table column
        let sequence = Sequence::new(
            "public".to_string(),
            "test_id_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(1),
            Some(1),
            Some(1000),
            Some(1),
            false,
            Some(1),
            Some(1),
            Some("public".to_string()),
            Some("test".to_string()),
            Some("id".to_string()),
        );
        from_dump.sequences.push(sequence);

        // Table that owns the sequence
        let column = TableColumn {
            catalog: "postgres".to_string(),
            schema: "public".to_string(),
            table: "test".to_string(),
            name: "id".to_string(),
            ordinal_position: 1,
            column_default: None,
            is_nullable: false,
            data_type: "bigint".to_string(),
            character_maximum_length: None,
            character_octet_length: None,
            numeric_precision: Some(64),
            numeric_precision_radix: Some(2),
            numeric_scale: Some(0),
            datetime_precision: None,
            interval_type: None,
            interval_precision: None,
            character_set_catalog: None,
            character_set_schema: None,
            character_set_name: None,
            collation_catalog: None,
            collation_schema: None,
            collation_name: None,
            domain_catalog: None,
            domain_schema: None,
            domain_name: None,
            udt_catalog: None,
            udt_schema: None,
            udt_name: None,
            scope_catalog: None,
            scope_schema: None,
            scope_name: None,
            maximum_cardinality: None,
            dtd_identifier: None,
            is_self_referencing: false,
            is_identity: true,
            identity_generation: Some("ALWAYS".to_string()),
            identity_start: Some("1".to_string()),
            identity_increment: Some("1".to_string()),
            identity_maximum: None,
            identity_minimum: None,
            identity_cycle: false,
            is_generated: "NEVER".to_string(),
            generation_expression: None,
            is_updatable: true,
            related_views: None,
        };

        let table = Table::new(
            "public".to_string(),
            "test".to_string(),
            "postgres".to_string(),
            None,
            vec![column],
            vec![],
            vec![],
            vec![],
            None,
        );
        from_dump.tables.push(table);

        let mut comparer = Comparer::new(from_dump, to_dump, true);
        comparer.compare_sequences().await.unwrap();
        let script = comparer.get_script();

        assert!(script.contains("Skipping drop of sequence public.test_id_seq as it is owned by table public.test which will be dropped."));
    }

    #[tokio::test]
    async fn compare_sequences_skips_drop_if_owned_by_identity_column() {
        let mut from_dump = Dump::new(DumpConfig::default());
        let mut to_dump = Dump::new(DumpConfig::default());

        // Sequence owned by table column
        let sequence = Sequence::new(
            "public".to_string(),
            "test_id_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(1),
            Some(1),
            Some(1000),
            Some(1),
            false,
            Some(1),
            Some(1),
            Some("public".to_string()),
            Some("test".to_string()),
            Some("id".to_string()),
        );
        from_dump.sequences.push(sequence);

        // Table with identity column in FROM
        let from_column = TableColumn {
            catalog: "postgres".to_string(),
            schema: "public".to_string(),
            table: "test".to_string(),
            name: "id".to_string(),
            ordinal_position: 1,
            column_default: None,
            is_nullable: false,
            data_type: "bigint".to_string(),
            character_maximum_length: None,
            character_octet_length: None,
            numeric_precision: Some(64),
            numeric_precision_radix: Some(2),
            numeric_scale: Some(0),
            datetime_precision: None,
            interval_type: None,
            interval_precision: None,
            character_set_catalog: None,
            character_set_schema: None,
            character_set_name: None,
            collation_catalog: None,
            collation_schema: None,
            collation_name: None,
            domain_catalog: None,
            domain_schema: None,
            domain_name: None,
            udt_catalog: None,
            udt_schema: None,
            udt_name: None,
            scope_catalog: None,
            scope_schema: None,
            scope_name: None,
            maximum_cardinality: None,
            dtd_identifier: None,
            is_self_referencing: false,
            is_identity: true,
            identity_generation: Some("ALWAYS".to_string()),
            identity_start: Some("1".to_string()),
            identity_increment: Some("1".to_string()),
            identity_maximum: None,
            identity_minimum: None,
            identity_cycle: false,
            is_generated: "NEVER".to_string(),
            generation_expression: None,
            is_updatable: true,
            related_views: None,
        };

        let from_table = Table::new(
            "public".to_string(),
            "test".to_string(),
            "postgres".to_string(),
            None,
            vec![from_column],
            vec![],
            vec![],
            vec![],
            None,
        );
        from_dump.tables.push(from_table);

        // Table in TO (exists, but maybe column changed or sequence changed)
        // Even if column is same, if sequence is missing in TO (simulated here by not adding it to to_dump.sequences),
        // we should skip drop if it's identity.
        let to_column = TableColumn {
            catalog: "postgres".to_string(),
            schema: "public".to_string(),
            table: "test".to_string(),
            name: "id".to_string(),
            ordinal_position: 1,
            column_default: None,
            is_nullable: false,
            data_type: "bigint".to_string(),
            character_maximum_length: None,
            character_octet_length: None,
            numeric_precision: Some(64),
            numeric_precision_radix: Some(2),
            numeric_scale: Some(0),
            datetime_precision: None,
            interval_type: None,
            interval_precision: None,
            character_set_catalog: None,
            character_set_schema: None,
            character_set_name: None,
            collation_catalog: None,
            collation_schema: None,
            collation_name: None,
            domain_catalog: None,
            domain_schema: None,
            domain_name: None,
            udt_catalog: None,
            udt_schema: None,
            udt_name: None,
            scope_catalog: None,
            scope_schema: None,
            scope_name: None,
            maximum_cardinality: None,
            dtd_identifier: None,
            is_self_referencing: false,
            is_identity: true, // Still identity
            identity_generation: Some("ALWAYS".to_string()),
            identity_start: Some("1".to_string()),
            identity_increment: Some("1".to_string()),
            identity_maximum: None,
            identity_minimum: None,
            identity_cycle: false,
            is_generated: "NEVER".to_string(),
            generation_expression: None,
            is_updatable: true,
            related_views: None,
        };

        let to_table = Table::new(
            "public".to_string(),
            "test".to_string(),
            "postgres".to_string(),
            None,
            vec![to_column],
            vec![],
            vec![],
            vec![],
            None,
        );
        to_dump.tables.push(to_table);

        let mut comparer = Comparer::new(from_dump, to_dump, true);
        comparer.compare_sequences().await.unwrap();
        let script = comparer.get_script();

        assert!(script.contains("Skipping drop of sequence public.test_id_seq as it is owned by identity column public.test.id."));
    }
}
