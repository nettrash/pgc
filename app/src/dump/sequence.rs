use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

// This is an information about a PostgreSQL sequence.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sequence {
    pub schema: String,                  // Schema where the sequence is defined
    pub name: String,                    // Name of the sequence
    pub owner: String,                   // Owner of the sequence
    pub data_type: String,               // Data type of the sequence
    pub start_value: Option<i64>,        // Start value of the sequence
    pub min_value: Option<i64>,          // Minimum value of the sequence
    pub max_value: Option<i64>,          // Maximum value of the sequence
    pub increment_by: Option<i64>,       // Increment value of the sequence
    pub cycle: bool,                     // Whether the sequence cycles
    pub cache_size: Option<i64>,         // Cache size of the sequence
    pub last_value: Option<i64>,         // Last value generated by the sequence
    pub owned_by_schema: Option<String>, // Schema of the owning table/column
    pub owned_by_table: Option<String>,  // Owning table name
    pub owned_by_column: Option<String>, // Owning column name
    pub hash: Option<String>,            // Hash of the sequence
}

impl Sequence {
    /// Creates a new Sequence with the given parameters
    #[allow(clippy::too_many_arguments)] // Sequence metadata naturally includes these fields from pg_sequence and pg_class.
    pub fn new(
        schema: String,
        name: String,
        owner: String,
        data_type: String,
        start_value: Option<i64>,
        min_value: Option<i64>,
        max_value: Option<i64>,
        increment_by: Option<i64>,
        cycle: bool,
        cache_size: Option<i64>,
        last_value: Option<i64>,
        owned_by_schema: Option<String>,
        owned_by_table: Option<String>,
        owned_by_column: Option<String>,
    ) -> Self {
        let mut sequence = Self {
            schema,
            name,
            owner,
            data_type,
            start_value,
            min_value,
            max_value,
            increment_by,
            cycle,
            cache_size,
            last_value,
            owned_by_schema,
            owned_by_table,
            owned_by_column,
            hash: None,
        };
        sequence.hash();
        sequence
    }

    /// Hash
    pub fn hash(&mut self) {
        let mut hasher = Sha256::new();

        hasher.update(self.schema.as_bytes());
        hasher.update(self.name.as_bytes());
        hasher.update(self.data_type.as_bytes());
        if let Some(start_value) = self.start_value {
            hasher.update(start_value.to_string().as_bytes());
        }
        if let Some(min_value) = self.min_value {
            hasher.update(min_value.to_string().as_bytes());
        }
        if let Some(max_value) = self.max_value {
            hasher.update(max_value.to_string().as_bytes());
        }
        if let Some(increment_by) = self.increment_by {
            hasher.update(increment_by.to_string().as_bytes());
        }
        hasher.update(self.cycle.to_string().as_bytes());
        if let Some(cache_size) = self.cache_size {
            hasher.update(cache_size.to_string().as_bytes());
        }

        self.hash = Some(format!("{:x}", hasher.finalize()));
    }

    fn render_owned_by_clause(&self) -> Option<String> {
        match (
            self.owned_by_schema.as_deref(),
            self.owned_by_table.as_deref(),
            self.owned_by_column.as_deref(),
        ) {
            (Some(schema), Some(table), Some(column)) => {
                let quote_ident = |ident: &str| format!("\"{}\"", ident.replace('"', "\"\""));
                Some(format!(
                    "owned by {}.{}.{}",
                    quote_ident(schema),
                    quote_ident(table),
                    quote_ident(column)
                ))
            }
            _ => None,
        }
    }

    /// Returns a string representation of the sequence
    pub fn get_script(&self) -> String {
        let mut script = String::new();

        // CREATE SEQUENCE statement
        script.push_str(&format!(
            "create sequence \"{}\".\"{}\"",
            self.schema, self.name
        ));

        // Add AS clause for data type if not default
        if !self.data_type.is_empty() && self.data_type != "bigint" {
            script.push_str(&format!(" as {}", self.data_type));
        }

        // Add START WITH clause
        if let Some(start_value) = self.start_value {
            script.push_str(&format!(" start with {start_value}"));
        }

        // Add INCREMENT BY clause
        if let Some(increment_by) = self.increment_by
            && increment_by != 1
        {
            script.push_str(&format!(" increment by {increment_by}"));
        }

        // Add MINVALUE clause
        if let Some(min_value) = self.min_value {
            script.push_str(&format!(" minvalue {min_value}"));
        } else {
            script.push_str(" no minvalue");
        }

        // Add MAXVALUE clause
        if let Some(max_value) = self.max_value {
            script.push_str(&format!(" maxvalue {max_value}"));
        } else {
            script.push_str(" no maxvalue");
        }

        // Add CACHE clause
        if let Some(cache_size) = self.cache_size
            && cache_size != 1
        {
            script.push_str(&format!(" cache {cache_size}"));
        }

        // Add CYCLE clause
        if self.cycle {
            script.push_str(" cycle");
        } else {
            script.push_str(" no cycle");
        }

        script.push_str(";\n");

        script
    }

    pub fn get_drop_script(&self) -> String {
        format!(
            "drop sequence if exists \"{}\".\"{}\";\n",
            self.schema, self.name
        )
    }

    pub fn get_alter_script(&self) -> String {
        let mut clauses = Vec::new();

        if let Some(start_value) = self.start_value {
            clauses.push(format!("start with {start_value}"));
        }
        if let Some(increment_by) = self.increment_by {
            clauses.push(format!("increment by {increment_by}"));
        }
        if let Some(min_value) = self.min_value {
            clauses.push(format!("minvalue {min_value}"));
        } else {
            clauses.push("no minvalue".to_string());
        }
        if let Some(max_value) = self.max_value {
            clauses.push(format!("maxvalue {max_value}"));
        } else {
            clauses.push("no maxvalue".to_string());
        }
        if let Some(cache_size) = self.cache_size {
            clauses.push(format!("cache {cache_size}"));
        }
        clauses.push(if self.cycle {
            "cycle".to_string()
        } else {
            "no cycle".to_string()
        });

        if let Some(owned_by) = self.render_owned_by_clause() {
            clauses.push(owned_by);
        }

        let mut script = format!("alter sequence \"{}\".\"{}\"", self.schema, self.name);
        if !clauses.is_empty() {
            script.push(' ');
            script.push_str(&clauses.join(" "));
        }
        script.push_str(";\n");

        script
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn build_sequence() -> Sequence {
        Sequence::new(
            "public".to_string(),
            "order_id_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(1),
            Some(1),
            Some(1000),
            Some(5),
            true,
            Some(20),
            Some(42),
            Some("public".to_string()),
            Some("orders".to_string()),
            Some("id".to_string()),
        )
    }

    #[test]
    fn test_sequence_new_initializes_hash() {
        let sequence = build_sequence();

        let mut hasher = Sha256::new();
        hasher.update("public".as_bytes());
        hasher.update("order_id_seq".as_bytes());
        hasher.update("bigint".as_bytes());
        hasher.update("1".as_bytes());
        hasher.update("1".as_bytes());
        hasher.update("1000".as_bytes());
        hasher.update("5".as_bytes());
        hasher.update("true".as_bytes());
        hasher.update("20".as_bytes());

        let expected_hash = format!("{:x}", hasher.finalize());

        assert_eq!(sequence.hash.as_deref(), Some(expected_hash.as_str()));
    }

    #[test]
    fn test_get_script_with_all_options() {
        let sequence = build_sequence();

        let script = sequence.get_script();

        assert_eq!(
            script,
            "create sequence \"public\".\"order_id_seq\" start with 1 increment by 5 minvalue 1 maxvalue 1000 cache 20 cycle;\n",
        );
    }

    #[test]
    fn test_get_script_uses_defaults() {
        let sequence = Sequence::new(
            "public".to_string(),
            "minimal_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            None,
            None,
            None,
            None,
            false,
            None,
            None,
            None,
            None,
            None,
        );

        assert_eq!(
            sequence.get_script(),
            "create sequence \"public\".\"minimal_seq\" no minvalue no maxvalue no cycle;\n",
        );
    }

    #[test]
    fn test_get_drop_script() {
        let sequence = build_sequence();
        assert_eq!(
            sequence.get_drop_script(),
            "drop sequence if exists \"public\".\"order_id_seq\";\n"
        );
    }

    #[test]
    fn test_get_alter_script_includes_owned_by() {
        let sequence = build_sequence();

        assert_eq!(
            sequence.get_alter_script(),
            "alter sequence \"public\".\"order_id_seq\" start with 1 increment by 5 minvalue 1 maxvalue 1000 cache 20 cycle owned by \"public\".\"orders\".\"id\";\n",
        );
    }

    #[test]
    fn test_get_alter_script_escapes_owned_by_identifiers() {
        let sequence = Sequence::new(
            "audit".to_string(),
            "event_seq".to_string(),
            "postgres".to_string(),
            "bigint".to_string(),
            Some(10),
            None,
            None,
            Some(2),
            false,
            None,
            None,
            Some("my\"schema".to_string()),
            Some("my.table".to_string()),
            Some("\"column\"".to_string()),
        );

        assert_eq!(
            sequence.get_alter_script(),
            "alter sequence \"audit\".\"event_seq\" start with 10 increment by 2 no minvalue no maxvalue no cycle owned by \"my\"\"schema\".\"my.table\".\"\"\"column\"\"\";\n",
        );
    }
}
