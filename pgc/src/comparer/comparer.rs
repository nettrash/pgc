use crate::dump::dump::Dump;
use std::{
    fs::File,
    io::{Error, Write},
};

// This is a Dump comparer that generates a script comparing two PostgreSQL dumps.
// The result script, if it will be applied on "from" dump database, will make it equal to "to" dump database.
pub struct Comparer {
    // The dump to compare from
    from: Dump,
    // The dump to compare to
    to: Dump,

    // The script that will be generated
    script: String,
}

impl Comparer {
    // Creates a new Comparer with the given dumps
    pub fn new(from: Dump, to: Dump) -> Self {
        let mut comparer = Self {
            from,
            to,
            script: String::new(),
        };

        comparer.script.push_str("/*\n");
        comparer
            .script
            .push_str("Script generated by PostgreSQL Comparer\n\n");
        comparer.script.push_str(" From dump:\n");
        comparer.script.push_str(&comparer.from.get_info());
        comparer.script.push_str("\n\n To dump:\n");
        comparer.script.push_str(&comparer.to.get_info());
        comparer.script.push_str("\n\n Comparison results:\n");
        comparer.script.push_str("*/\n\n");

        comparer
    }

    // Compare dumps and generate the script
    pub async fn compare(&mut self) -> Result<(), Error> {
        self.compare_extensions().await?;
        self.compare_types().await?;
        self.compare_enums().await?;
        self.compare_routines().await?;
        self.compare_tables().await?;

        Ok(())
    }

    // Returns the script generated by the comparer
    fn get_script(&self) -> String {
        self.script.clone()
    }

    // Saves the generated script to a file
    pub async fn save_script(&self, output: &str) -> Result<(), Error> {
        let mut file = File::create(output)?;
        file.write_all(self.get_script().as_bytes())?;
        Ok(())
    }

    // Comparing extentions
    async fn compare_extensions(&mut self) -> Result<(), Error> {
        self.script.push_str("/* Extensions */\n");
        Ok(())
    }

    // Comparing types
    async fn compare_types(&mut self) -> Result<(), Error> {
        self.script.push_str("/* User-defined types */\n");
        Ok(())
    }

    // Comparing enums
    async fn compare_enums(&mut self) -> Result<(), Error> {
        self.script.push_str("/* Enums */\n");
        Ok(())
    }

    // Comparing routines
    async fn compare_routines(&mut self) -> Result<(), Error> {
        self.script.push_str("/* Routines: Start section */\n");

        // We will find all new routines from "to" dump that are not in "from" dump
        // and we will find all existing routines in both dumps with different hashes
        // and add them to the script.
        for routine in &self.to.routines {
            if let Some(from_routine) = self.from.routines.iter().find(|r| r.name == routine.name && r.schema == routine.schema) {
                if from_routine.hash() != routine.hash() {
                    self.script.push_str(format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str());
                    self.script.push_str(routine.get_script().as_str());
                }
            } else {
                    self.script.push_str(format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str());
                    self.script.push_str(routine.get_script().as_str());
            }
        }

        for routine in &self.from.routines {
            if let Some(_to_routine) = self.to.routines.iter().find(|r| r.name == routine.name && r.schema == routine.schema) {
                continue; // Routine is present in both dumps, we already processed it
            } else {
                self.script.push_str(format!("/* Routine: {}.{}*/\n", routine.schema, routine.name).as_str());
                self.script.push_str("/* Routine is not present in 'to' dump and should be dropped. */\n");
                self.script.push_str(routine.get_drop_script().as_str());
            }
        }

        self.script.push_str("/* Routines: End section */\n");
        Ok(())
    }

    // Comparing tables
    async fn compare_tables(&mut self) -> Result<(), Error> {
        self.script.push_str("/* Tables */\n");
        Ok(())
    }
}
